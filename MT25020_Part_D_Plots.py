import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import os

# ---------------------------------------------------------
# CONFIGURATION
# ---------------------------------------------------------
# Load data from the CSV file generated by your script
CSV_FILE = "MT25020_Part_C_Results.csv"

# If the CSV doesn't exist yet, we can't plot.
if not os.path.exists(CSV_FILE):
    print(f"Error: {CSV_FILE} not found. Run the bash script first.")
    exit(1)

df = pd.read_csv(CSV_FILE)

# Ensure columns are numeric
cols = ['ThroughputGbps', 'LatencyUs', 'CPUCycles', 'LLCMisses', 'ContextSwitches']
for col in cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

# System Config for the plot title/legend
SYSTEM_CONFIG = "System: Hybrid CPU (P-Core/E-Core) | Linux Network Namespace | veth pair"

# Create directory for plots
if not os.path.exists("plots"):
    os.makedirs("plots")

# ---------------------------------------------------------
# PLOT 1: Throughput vs Message Size (for Thread=1)
# ---------------------------------------------------------
def plot_throughput_vs_msgsize():
    plt.figure(figsize=(10, 6))
    
    # Filter for 1 thread to see pure protocol efficiency
    data = df[df['Threads'] == 1]
    
    # Plot lines for each implementation
    for impl, marker in zip(['A1', 'A2', 'A3'], ['o', 's', '^']):
        subset = data[data['Impl'] == impl]
        plt.plot(subset['MsgSize'], subset['ThroughputGbps'], marker=marker, label=f"{impl} (1 Thread)")

    plt.title(f"Throughput vs Message Size\n{SYSTEM_CONFIG}")
    plt.xlabel("Message Size (Bytes)")
    plt.ylabel("Throughput (Gbps)")
    plt.xscale('log', base=2) # Log scale makes 1024->65536 look better
    plt.grid(True, which="both", ls="-", alpha=0.5)
    plt.legend()
    plt.savefig("plots/Throughput_vs_MsgSize.png")
    print("Generated plots/Throughput_vs_MsgSize.png")

# ---------------------------------------------------------
# PLOT 2: Latency vs Thread Count (for MsgSize=4096)
# ---------------------------------------------------------
def plot_latency_vs_threads():
    plt.figure(figsize=(10, 6))
    
    # Fix message size to 4096 for comparison
    target_size = 4096
    data = df[df['MsgSize'] == target_size]
    
    for impl, marker in zip(['A1', 'A2', 'A3'], ['o', 's', '^']):
        subset = data[data['Impl'] == impl]
        plt.plot(subset['Threads'], subset['LatencyUs'], marker=marker, label=f"{impl} ({target_size}B)")

    plt.title(f"Latency vs Thread Count (MsgSize={target_size})\n{SYSTEM_CONFIG}")
    plt.xlabel("Thread Count")
    plt.ylabel("Latency (Âµs)")
    
    # ADDED: Log scale to see the doubling trend clearly
    # If A3 is way higher than A1, linear scale hides A1's growth.
    # Log scale shows the slope accurately.
    # plt.yscale('log')  <-- Uncomment this if A3 makes A1 look flat
    
    plt.grid(True, ls="-", alpha=0.5)
    plt.legend()
    plt.savefig("plots/Latency_vs_Threads.png")
    print("Generated plots/Latency_vs_Threads.png")
    
# ---------------------------------------------------------
# PLOT 3: LLC Misses vs Message Size (Thread=1)
# ---------------------------------------------------------
def plot_cache_vs_msgsize():
    plt.figure(figsize=(10, 6))
    
    data = df[df['Threads'] == 1]
    
    for impl, marker in zip(['A1', 'A2', 'A3'], ['o', 's', '^']):
        subset = data[data['Impl'] == impl]
        plt.plot(subset['MsgSize'], subset['LLCMisses'], marker=marker, label=impl)

    plt.title(f"LLC Cache Misses vs Message Size\n{SYSTEM_CONFIG}")
    plt.xlabel("Message Size (Bytes)")
    plt.ylabel("LLC Misses (Events)")
    plt.xscale('log', base=2)
    plt.grid(True, ls="-", alpha=0.5)
    plt.legend()
    plt.savefig("plots/CacheMisses_vs_MsgSize.png")
    print("Generated plots/CacheMisses_vs_MsgSize.png")

# ---------------------------------------------------------
# PLOT 4: CPU Cycles per Byte (Efficiency)
# ---------------------------------------------------------
def plot_cycles_per_byte():
    plt.figure(figsize=(10, 6))
    
    data = df[df['Threads'] == 1]
    DURATION_SEC = 10.0 # We ran for 10 seconds in the bash script
    
    for impl, marker in zip(['A1', 'A2', 'A3'], ['o', 's', '^']):
        subset = data[data['Impl'] == impl]
        
        # CORRECT FORMULA:
        # 1. Total Bits = Throughput(Gbps) * 1e9 * Duration
        # 2. Total Bytes = Total Bits / 8
        # 3. Efficiency = Total CPU Cycles / Total Bytes
        
        total_bytes = (subset['ThroughputGbps'] * 1e9 * DURATION_SEC) / 8.0
        cycles_per_byte = subset['CPUCycles'] / total_bytes
        
        plt.plot(subset['MsgSize'], cycles_per_byte, marker=marker, label=impl)

    plt.title(f"CPU Efficiency (Cycles per Byte Transferred)\n{SYSTEM_CONFIG}")
    plt.xlabel("Message Size (Bytes)")
    plt.ylabel("CPU Cycles per Byte (Lower is Better)")
    plt.xscale('log', base=2)
    plt.yscale('log')
    plt.grid(True, which="both", ls="-", alpha=0.5)
    plt.legend()
    plt.savefig("plots/CPUCycles_vs_MsgSize.png")
    print("Generated plots/CPUCycles_vs_MsgSize.png")

# ---------------------------------------------------------
# MAIN
# ---------------------------------------------------------
if __name__ == "__main__":
    try:
        plot_throughput_vs_msgsize()
        plot_latency_vs_threads()
        plot_cache_vs_msgsize()
        plot_cycles_per_byte()
        print("\nAll plots generated successfully in 'plots/' folder.")
    except Exception as e:
        print(f"An error occurred: {e}")